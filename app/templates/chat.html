{% extends "base.html" %}

{% block title %}Chat - NoteBoard{% endblock %}

{% block content %}
<div class="px-4 py-6 sm:px-0">
    <div class="max-w-7xl mx-auto">
        <div class="flex gap-4" style="height: calc(100vh - 8rem);">
            <!-- Threads Panel -->
            <div class="w-80 bg-white dark:bg-slate-800 rounded-lg shadow-sm border border-gray-200 dark:border-slate-700 flex flex-col transition-colors duration-200">
                <!-- Threads Header -->
                <div class="p-4 border-b border-gray-200 dark:border-slate-700">
                    <div class="flex items-center justify-between mb-3">
                        <h3 class="text-lg font-semibold text-gray-900 dark:text-slate-100">Threads</h3>
                        <div class="flex items-center gap-2">
                            <button 
                                id="multi-select-btn"
                                class="text-sm text-gray-600 dark:text-slate-400 hover:text-gray-900 dark:hover:text-slate-200 p-1.5 rounded-lg hover:bg-gray-100 dark:hover:bg-slate-700 transition-colors"
                                title="Select multiple threads (Cmd/Ctrl+Click)"
                            >
                                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                                </svg>
                            </button>
                            <button 
                                id="refresh-threads-btn"
                                class="text-sm text-indigo-600 dark:text-indigo-400 hover:text-indigo-700 dark:hover:text-indigo-300"
                                title="Refresh threads"
                            >
                                â†»
                            </button>
                        </div>
                    </div>
                    <!-- Multi-select Controls -->
                    <div id="multi-select-controls" class="hidden mb-3">
                        <div class="flex gap-2">
                            <button onclick="exitMultiSelectMode()" class="flex-1 px-4 py-2 text-sm text-gray-700 dark:text-slate-300 hover:bg-gray-100 dark:hover:bg-slate-700 rounded-lg font-medium transition-colors">
                                Cancel
                            </button>
                            <button onclick="deleteSelectedThreads()" class="flex-1 bg-red-600 text-white px-4 py-2 rounded-lg hover:bg-red-700 text-sm font-medium shadow-sm hover:shadow-md transition-all duration-200 inline-flex items-center justify-center gap-2 whitespace-nowrap">
                                <svg class="w-4 h-4 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path>
                                </svg>
                                <span>Delete</span>
                                <span id="selected-count" class="font-semibold">0</span>
                            </button>
                        </div>
                    </div>
                    <!-- Search Input -->
                    <input 
                        type="text" 
                        id="thread-search-input" 
                        placeholder="Search threads..." 
                        class="w-full px-3 py-2 text-sm border border-gray-300 dark:border-slate-600 rounded-md focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-transparent bg-white dark:bg-slate-700 text-gray-900 dark:text-slate-100 placeholder-gray-400 dark:placeholder-slate-400"
                        autocomplete="off"
                    >
                </div>
                
                <!-- Threads List -->
                <div class="flex-1 overflow-y-auto p-2" id="threads-list">
                    <div class="text-center text-gray-400 dark:text-slate-500 text-sm py-8">
                        Loading threads...
                    </div>
                </div>
            </div>
            
            <!-- Main Chat Area -->
            <div class="flex-1 bg-white dark:bg-slate-800 rounded-lg shadow-sm border border-gray-200 dark:border-slate-700 flex flex-col transition-colors duration-200">
                <!-- Chat Header -->
                <div class="p-4 border-b border-gray-200 dark:border-slate-700">
                    <div class="flex items-center justify-between mb-2">
                        <div>
                            <h2 class="text-lg font-semibold text-gray-900 dark:text-slate-100">Chat with Your Notes</h2>
                            <p class="text-sm text-gray-500 dark:text-slate-400 mt-1">Ask questions about your notes using AI</p>
                        </div>
                        <div class="flex items-center space-x-2">
                            <label for="assistant-select" class="text-sm text-gray-700 dark:text-slate-300 whitespace-nowrap">Assistant:</label>
                            <select 
                                id="assistant-select" 
                                class="px-3 py-1.5 text-sm border border-gray-300 dark:border-slate-600 rounded-md focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-transparent bg-white dark:bg-slate-700 text-gray-900 dark:text-slate-100"
                            >
                                <option value="">Loading...</option>
                            </select>
                        </div>
                    </div>
                </div>
                
                <!-- Messages -->
                <div class="flex-1 overflow-y-auto p-4 space-y-4 bg-white dark:bg-slate-800" id="chat-messages">
                    <div class="text-center text-gray-400 dark:text-slate-500 text-sm py-8">
                        Start a conversation by typing a message below
                    </div>
                </div>
                
                <!-- Input Area -->
                <div class="p-4 border-t border-gray-200 dark:border-slate-700 bg-white dark:bg-slate-800">
                    <form id="chat-form" class="flex space-x-2">
                        <input 
                            type="text" 
                            id="chat-input" 
                            placeholder="Type your message..." 
                            class="flex-1 px-4 py-2 border border-gray-300 dark:border-slate-600 rounded-md focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-transparent bg-white dark:bg-slate-700 text-gray-900 dark:text-slate-100 placeholder-gray-400 dark:placeholder-slate-400"
                            autocomplete="off"
                        >
                        <button 
                            type="submit" 
                            class="px-6 py-2 bg-gradient-to-r from-indigo-600 to-purple-600 text-white rounded-md hover:from-indigo-700 hover:to-purple-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 dark:focus:ring-offset-slate-800 transition-all duration-200"
                        >
                            Send
                        </button>
                    </form>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
const messages = [];
let selectedAssistantId = null;
let allThreads = []; // Store all threads for filtering
let selectedThreads = new Set(); // Track selected threads for multi-select
let multiSelectMode = false; // Track if we're in multi-select mode
let currentThreadId = null; // Track currently selected thread

document.addEventListener('DOMContentLoaded', async () => {
    const form = document.getElementById('chat-form');
    const input = document.getElementById('chat-input');
    const assistantSelect = document.getElementById('assistant-select');
    const refreshThreadsBtn = document.getElementById('refresh-threads-btn');
    const threadSearchInput = document.getElementById('thread-search-input');
    const multiSelectBtn = document.getElementById('multi-select-btn');
    
    // Load assistants
    await loadAssistants();
    
    // Handle assistant selection change
    assistantSelect.addEventListener('change', (e) => {
        selectedAssistantId = e.target.value || null;
        // Exit multi-select mode when switching assistants
        if (multiSelectMode) {
            exitMultiSelectMode();
        }
        currentThreadId = null;
        messages.length = 0;
        renderMessages();
        loadThreads();
    });
    
    // Handle refresh threads button
    refreshThreadsBtn.addEventListener('click', () => {
        loadThreads(true); // Force refresh
    });
    
    // Handle multi-select button
    multiSelectBtn.addEventListener('click', () => {
        enterMultiSelectMode();
    });
    
    // Handle thread search input
    threadSearchInput.addEventListener('input', (e) => {
        filterThreads(e.target.value);
    });
    
    form.addEventListener('submit', async (e) => {
        e.preventDefault();
        const message = input.value.trim();
        if (!message) return;
        
        input.value = '';
        await sendMessage(message);
    });
});

async function loadAssistants() {
    try {
        const response = await apiCall('/api/assistants', {
            method: 'GET'
        });
        
        const select = document.getElementById('assistant-select');
        select.innerHTML = '<option value="">Select an assistant...</option>';
        
        if (response && Array.isArray(response)) {
            response.forEach(assistant => {
                const option = document.createElement('option');
                option.value = assistant.assistant_id;
                option.textContent = `${assistant.name} (${assistant.memory_count || 0} memories)`;
                select.appendChild(option);
            });
            
            // Select the first assistant by default if available
            if (response.length > 0) {
                select.value = response[0].assistant_id;
                selectedAssistantId = response[0].assistant_id;
                // Load threads for the selected assistant
                loadThreads();
            }
        }
    } catch (error) {
        console.error('Failed to load assistants:', error);
        const select = document.getElementById('assistant-select');
        select.innerHTML = '<option value="">Error loading assistants</option>';
    }
}

function addMessage(role, content) {
    messages.push({ role, content });
    renderMessages();
}

function renderMessages() {
    const container = document.getElementById('chat-messages');
    
    if (messages.length === 0) {
        container.innerHTML = '<div class="text-center text-gray-400 dark:text-slate-500 text-sm py-8">Start a conversation by typing a message below</div>';
        return;
    }
    
    container.innerHTML = messages.map(msg => {
        const isUser = msg.role === 'user';
        return `
            <div class="flex ${isUser ? 'justify-end' : 'justify-start'}">
                <div class="max-w-3xl ${isUser ? 'bg-gradient-to-r from-indigo-600 to-purple-600 text-white' : 'bg-gray-100 dark:bg-slate-700 text-gray-900 dark:text-slate-100'} rounded-lg px-4 py-2 chat-message">
                    <div class="text-sm whitespace-pre-wrap">${escapeHtml(msg.content)}</div>
                </div>
            </div>
        `;
    }).join('');
    
    container.scrollTop = container.scrollHeight;
}

async function sendMessage(message) {
    addMessage('user', message);
    
    // Show loading indicator
    const loadingId = Date.now();
    addMessage('assistant', 'Thinking...');
    
    try {
        const requestBody = { message };
        if (selectedAssistantId) {
            requestBody.assistant_id = selectedAssistantId;
        }
        // If we have a current thread, continue using it
        if (currentThreadId) {
            requestBody.thread_id = currentThreadId;
        }
        
        const response = await apiCall('/api/chat', {
            method: 'POST',
            body: JSON.stringify(requestBody)
        });
        
        // Remove loading message and add actual response
        messages.pop();
        addMessage('assistant', response.response || 'No response received');
        
        // Update current thread ID if returned
        if (response.thread_id) {
            currentThreadId = response.thread_id;
            console.log('Message sent to thread:', response.thread_id);
        }
        // Always refresh threads after sending a message (force refresh to get new thread)
        setTimeout(() => loadThreads(true), 500); // Small delay to ensure thread is saved
    } catch (error) {
        console.error('Chat error:', error);
        messages.pop();
        addMessage('assistant', 'Error: ' + error.message);
    }
}

function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

async function loadThreads(forceRefresh = false) {
    const threadsList = document.getElementById('threads-list');
    
    if (!selectedAssistantId) {
        threadsList.innerHTML = '<div class="text-center text-gray-400 dark:text-slate-500 text-sm py-8">Select an assistant to view threads</div>';
        allThreads = [];
        return;
    }
    
    try {
        threadsList.innerHTML = '<div class="text-center text-gray-400 dark:text-slate-500 text-sm py-8">Loading threads...</div>';
        
        const url = `/api/threads?assistant_id=${encodeURIComponent(selectedAssistantId)}${forceRefresh ? '&force_refresh=true' : ''}`;
        const response = await apiCall(url, {
            method: 'GET'
        });
        
        console.log('Threads API response:', response);
        
        // Handle error response
        if (response && response.error) {
            console.error('Threads API error:', response.error);
            threadsList.innerHTML = `<div class="text-center text-red-400 dark:text-red-500 text-sm py-8">Error: ${escapeHtml(response.error)}</div>`;
            allThreads = [];
            return;
        }
        
        if (!response || !Array.isArray(response) || response.length === 0) {
            threadsList.innerHTML = '<div class="text-center text-gray-400 dark:text-slate-500 text-sm py-8">No threads found</div>';
            allThreads = [];
            return;
        }
        
        console.log(`Loaded ${response.length} threads`);
        console.log('Sample thread data:', response[0]); // Debug: log first thread to see structure
        
        // Store all threads for filtering
        allThreads = response;
        
        // Apply current search filter if any
        const searchInput = document.getElementById('thread-search-input');
        filterThreads(searchInput ? searchInput.value : '');
        
    } catch (error) {
        console.error('Failed to load threads:', error);
        threadsList.innerHTML = `<div class="text-center text-red-400 dark:text-red-500 text-sm py-8">Error loading threads: ${escapeHtml(error.message)}</div>`;
        allThreads = [];
    }
}

function filterThreads(searchQuery) {
    const threadsList = document.getElementById('threads-list');
    
    if (!allThreads || allThreads.length === 0) {
        return;
    }
    
    const query = (searchQuery || '').trim().toLowerCase();
    
    // Filter threads by thread ID or preview text (case-insensitive)
    const filteredThreads = query 
        ? allThreads.filter(thread => {
            const threadId = (thread.thread_id || thread.id || '').toLowerCase();
            const previewText = (thread.preview_text || '').toLowerCase();
            return threadId.includes(query) || previewText.includes(query);
        })
        : allThreads;
    
    if (filteredThreads.length === 0) {
        threadsList.innerHTML = '<div class="text-center text-gray-400 dark:text-slate-500 text-sm py-8">No threads match your search</div>';
        return;
    }
    
    threadsList.innerHTML = filteredThreads.map(thread => {
        const threadId = thread.thread_id || thread.id || '';
        const createdAt = thread.created_at ? new Date(thread.created_at).toLocaleString() : 'Unknown date';
        const updatedAt = thread.updated_at ? new Date(thread.updated_at).toLocaleString() : 'Unknown date';
        
        // Use preview text if available, otherwise fall back to truncated thread ID
        const previewText = thread.preview_text || '';
        const displayText = previewText || (threadId.length > 50 ? threadId.substring(0, 50) + '...' : threadId);
        
        const isSelected = selectedThreads.has(threadId);
        const isActive = currentThreadId === threadId;
        
        // Build classes for thread item
        let itemClasses = 'p-3 mb-2 rounded-lg border border-gray-200 dark:border-slate-700 hover:bg-gray-50 dark:hover:bg-slate-700 cursor-pointer transition-colors duration-200 relative flex items-start gap-3 group';
        if (isActive) {
            itemClasses += ' bg-gradient-to-r from-indigo-50 dark:from-indigo-900/30 to-purple-50 dark:to-purple-900/30 border-indigo-200 dark:border-indigo-700';
        }
        if (isSelected) {
            itemClasses += ' bg-blue-50 dark:bg-blue-900/20';
        }
        
        // Only show checkbox in multi-select mode
        const checkboxHtml = multiSelectMode ? `
            <input 
                type="checkbox" 
                class="mt-1 w-4 h-4 text-indigo-600 focus:ring-indigo-500 border-gray-300 dark:border-slate-600 rounded cursor-pointer"
                ${isSelected ? 'checked' : ''}
                onclick="event.stopPropagation(); toggleThreadSelection('${escapeHtml(threadId)}')"
            >
        ` : '';
        
        return `
            <div class="${itemClasses}" 
                 data-thread-id="${escapeHtml(threadId)}"
                 title="Thread ID: ${escapeHtml(threadId)}">
                ${checkboxHtml}
                <div class="flex-1 min-w-0">
                    <div class="text-sm font-medium text-gray-900 dark:text-slate-100 mb-1 line-clamp-2">
                        ${escapeHtml(displayText)}
                    </div>
                    <div class="text-xs text-gray-500 dark:text-slate-400">
                        Updated: ${escapeHtml(updatedAt)}
                    </div>
                </div>
                <button 
                    onclick="event.stopPropagation(); deleteThread('${escapeHtml(threadId)}')" 
                    class="opacity-0 group-hover:opacity-100 transition-opacity duration-200 p-1.5 rounded-lg hover:bg-red-100 dark:hover:bg-red-900/30 text-red-600 dark:text-red-400 z-10 flex-shrink-0"
                    title="Delete thread"
                >
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path>
                    </svg>
                </button>
            </div>
        `;
    }).join('');
    
    // Add click handlers to thread items
    threadsList.querySelectorAll('[data-thread-id]').forEach(item => {
        item.addEventListener('click', (e) => {
            // Don't trigger selection if clicking on checkbox or delete button
            if (e.target.tagName === 'INPUT' || e.target.closest('button')) {
                return;
            }
            const threadId = item.getAttribute('data-thread-id');
            handleThreadClick(threadId, e);
        });
    });
}

function enterMultiSelectMode() {
    multiSelectMode = true;
    selectedThreads.clear();
    document.getElementById('multi-select-controls').classList.remove('hidden');
    document.getElementById('multi-select-btn').classList.add('hidden');
    filterThreads(document.getElementById('thread-search-input').value);
}

function exitMultiSelectMode() {
    multiSelectMode = false;
    selectedThreads.clear();
    document.getElementById('multi-select-controls').classList.add('hidden');
    document.getElementById('multi-select-btn').classList.remove('hidden');
    filterThreads(document.getElementById('thread-search-input').value);
}

function handleThreadClick(threadId, event) {
    if (multiSelectMode) {
        // In multi-select mode, clicking toggles selection
        toggleThreadSelection(threadId);
    } else {
        // Check if Cmd (Mac) or Ctrl (Windows/Linux) is pressed
        if (event.metaKey || event.ctrlKey) {
            // Enter multi-select mode and select this thread
            enterMultiSelectMode();
            toggleThreadSelection(threadId);
        } else {
            // Load thread messages
            loadThreadMessages(threadId);
        }
    }
}

function toggleThreadSelection(threadId) {
    if (selectedThreads.has(threadId)) {
        selectedThreads.delete(threadId);
    } else {
        selectedThreads.add(threadId);
    }
    updateBulkDeleteButton();
    filterThreads(document.getElementById('thread-search-input').value);
}

function updateBulkDeleteButton() {
    const countEl = document.getElementById('selected-count');
    if (multiSelectMode && countEl) {
        countEl.textContent = selectedThreads.size;
    }
}

async function loadThreadMessages(threadId) {
    try {
        const response = await apiCall(`/api/threads/${encodeURIComponent(threadId)}/messages`, {
            method: 'GET'
        });
        
        // Clear current messages and populate with thread messages
        messages.length = 0;
        if (response && Array.isArray(response)) {
            response.forEach(msg => {
                messages.push({
                    role: msg.role || 'user',
                    content: msg.content || ''
                });
            });
        }
        
        // Update current thread ID
        currentThreadId = threadId;
        
        // Render messages
        renderMessages();
        
        // Refresh thread list to highlight active thread
        filterThreads(document.getElementById('thread-search-input').value);
    } catch (error) {
        console.error('Failed to load thread messages:', error);
        alert('Failed to load thread messages: ' + error.message);
    }
}

async function deleteThread(threadId) {
    if (!confirm('Are you sure you want to delete this thread?')) {
        return;
    }
    
    // Optimistically remove thread from UI immediately
    const threadIndex = allThreads.findIndex(t => (t.thread_id || t.id) === threadId);
    const deletedThread = threadIndex >= 0 ? allThreads[threadIndex] : null;
    
    // Remove from threads array immediately
    if (threadIndex >= 0) {
        allThreads.splice(threadIndex, 1);
    }
    
    // If deleted thread was currently selected, clear chat
    if (currentThreadId === threadId) {
        currentThreadId = null;
        messages.length = 0;
        renderMessages();
    }
    
    // Remove from selected threads if it was selected
    if (selectedThreads && selectedThreads.has(threadId)) {
        selectedThreads.delete(threadId);
        updateBulkDeleteButton();
    }
    
    // Update UI immediately
    filterThreads(document.getElementById('thread-search-input').value);
    
    // Then sync with server
    try {
        await apiCall(`/api/threads/${encodeURIComponent(threadId)}`, {
            method: 'DELETE'
        });
    } catch (error) {
        console.error('Failed to delete thread:', error);
        
        // Revert the optimistic update on error
        if (deletedThread && threadIndex >= 0) {
            allThreads.splice(threadIndex, 0, deletedThread);
            filterThreads(document.getElementById('thread-search-input').value);
        }
        
        // If error is "Thread not found", the thread might already be deleted
        if (error.message && error.message.includes('not found')) {
            // Thread already deleted, UI is correct
            return;
        } else {
            alert('Failed to delete thread: ' + error.message);
            // Refresh to ensure UI is in sync
            await loadThreads(true);
        }
    }
}

async function deleteSelectedThreads() {
    if (selectedThreads.size === 0) {
        return;
    }
    
    const count = selectedThreads.size;
    if (!confirm(`Are you sure you want to delete ${count} thread${count > 1 ? 's' : ''}?`)) {
        return;
    }
    
    const threadIds = Array.from(selectedThreads);
    
    // Optimistically remove threads from UI immediately
    threadIds.forEach(threadId => {
        const threadIndex = allThreads.findIndex(t => (t.thread_id || t.id) === threadId);
        if (threadIndex >= 0) {
            allThreads.splice(threadIndex, 1);
        }
        
        // If deleted thread was currently selected, clear chat
        if (currentThreadId === threadId) {
            currentThreadId = null;
            messages.length = 0;
            renderMessages();
        }
    });
    
    // Update UI immediately
    selectedThreads.clear();
    exitMultiSelectMode();
    
    // Then sync with server
    try {
        await apiCall('/api/threads/bulk', {
            method: 'DELETE',
            body: JSON.stringify({ thread_ids: threadIds })
        });
        
        // Refresh thread list to ensure sync
        await loadThreads(true);
    } catch (error) {
        console.error('Failed to delete threads:', error);
        alert('Failed to delete threads: ' + error.message);
        // Refresh to ensure UI is in sync
        await loadThreads(true);
        selectedThreads.clear();
        exitMultiSelectMode();
    }
}
</script>
{% endblock %}
